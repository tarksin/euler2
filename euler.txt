#1  Multiples of 3 and 5
If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
Find the sum of all the multiples of 3 or 5 below 1000.

euler_digits=1..999
el_total=0    
euler_digits.each {
        |digit| if digit % 3 == 0 || digit % 5 == 0 then el_total += digit  end 
       }
puts "el_total== #{el_total}"

233168 


#2  Even Fibonacci numbers

Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: 
1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

fib_a=1
fib_b=2
fib_sum=3
euler_sum=2
   
while true      
    fib_a=fib_b
    fib_b=fib_sum
    fib_sum=fib_a + fib_b
break if fib_sum > 4_000_000    
    
    if fib_sum % 2 == 0 
      euler_sum += fib_sum 
    end
end    

puts  "final: #{euler_sum.to_s}"    

4613732 


#3  Largest prime factor   

The prime factors of 13195 are 5, 7, 13 and 29.
What is the largest prime factor of the number 600851475143 ?

dividend= 600_851_475_143 
upper_limit=Math.sqrt(dividend)
divisor=3   #obviously it's not 2

while dividend > upper_limit do
  if dividend % divisor > 0 then  
     divisor+=1 
  else 
      dividend = dividend/divisor
      divisor=2
  end #if/else
end #while

puts "answer:#{dividend.to_s}"   

6857


#4  Largest palindrome product

A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
Find the largest palindrome made from the product of two 3-digit numbers.

s_target=""
target, l_target, c0,c1,c2,c3,c4,c5,c6=0
current_euler=0

for x in 999.downto(100) 
  for z in 999.downto(100) 
       target = x*z
       s_target=target.to_s
       #l_target=s_target.length
       if target > 99999 then # 6+ char
           c0=s_target[0]
           c5=s_target[5]
           if c0==c5 then
             c1=s_target[1]
             c4=s_target[4]
             if c1==c4 then
               c2=s_target[2]
               c3=s_target[3]
               if c2==c3 then
                 current_euler = target if target > current_euler  
                 break            
               end # c2 c3   
             end  # c1 c4    
           end  #  c0 c5  
       end # >  99999   
  end  # z
end  #x
puts "the end #{current_euler}" 

906609
 

#5  Smallest multiple   

2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
…...…  code not saved   :(
232792560                  Completed on Mon, 8 May 2017, 08:05 







#6  Sum square difference

The sum of the squares of the first ten natural numbers is,
12 + 22 + ... + 102 = 385
The square of the sum of the first ten natural numbers is,
(1 + 2 + ... + 10)2 = 552 = 3025
Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 ? 385 = 2640.
Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.

sum1=0
sum2=0
square1=0
euler=0
1.upto(100) do |i|
    sum1+= i
 end # 1.upto 100
square1=sum1 * sum1

1.upto(100) do |j|
    sum2+= j*j
end # 1.upto 100

euler = square1 - sum2
puts "euler=#{euler}"

25502500 - 338350= 25164150 


#7  10001st prime  

By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
What is the 10 001st prime number?

transitor=11
divisor=3
primeCount=5  #2,3,5,7,11
theMod=0
isPrime=true
while primeCount< 10001
  transitor+=2
  divisor=3
  isPrime=true
  while divisor < transitor/2
    divisor+=2
    theMod=transitor % divisor
      if theMod == 0 
      isPrime=false;
      break
    end
  end #while divisor < transitor/2
  if isPrime 
    primeCount+=1
  end
end   # while primeCount<10k
  
puts(primeCount.to_s + ':' + transitor.to_s)

232792560   



#8  Largest product in a series

The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.

73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450
Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?

#function to get product of elements of array parameter
def getProd(arr)
  n=1
  arr.each {|r|
      n = n * r
      }
  return n
end
 
winningProduct=0   #init
# array containing the 1000 digits
n1000=[7,3,1,6,7,1,7,6,5,3,1,3,3,0,6,2,4,9,1,9,2,2,5,1,1,9,6,7,4,4,2,6,5,7,4,7,4,2,3,5,5,3,4,9,1,9,4,9,3,4,9,6,9,8,3,5,2,0,3,1,2,7,7,4,5,0,6,3,2,6,2,3,9,5,7,8,3,1,8,0,1,6,9,8,4,8,0,1,8,6,9,4,7,8,8,5,1,8,4,3,8,5,8,6,1,5,6,0,7,8,9,1,1,2,9,4,9,4,9,5,4,5,9,5,0,1,7,3,7,9,5,8,3,3,1,9,5,2,8,5,3,2,0,8,8,0,5,5,1,1,1,2,5,4,0,6,9,8,7,4,7,1,5,8,5,2,3,8,6,3,0,5,0,7,1,5,6,9,3,2,9,0,9,6,3,2,9,5,2,2,7,4,4,3,0,4,3,5,5,7,6,6,8,9,6,6,4,8,9,5,0,4,4,5,2,4,4,5,2,3,1,6,1,7,3,1,8,5,6,4,0,3,0,9,8,7,1,1,1,2,1,7,2,2,3,8,3,1,1,3,6,2,2,2,9,8,9,3,4,2,3,3,8,0,3,0,8,1,3,5,3,3,6,2,7,6,6,1,4,2,8,2,8,0,6,4,4,4,4,8,6,6,4,5,2,3,8,7,4,9,3,0,3,5,8,9,0,7,2,9,6,2,9,0,4,9,1,5,6,0,4,4,0,7,7,2,3,9,0,7,1,3,8,1,0,5,1,5,8,5,9,3,0,7,9,6,0,8,6,6,7,0,1,7,2,4,2,7,1,2,1,8,8,3,9,9,8,7,9,7,9,0,8,7,9,2,2,7,4,9,2,1,9,0,1,6,9,9,7,2,0,8,8,8,0,9,3,7,7,6,6,5,7,2,7,3,3,3,0,0,1,0,5,3,3,6,7,8,8,1,2,2,0,2,3,5,4,2,1,8,0,9,7,5,1,2,5,4,5,4,0,5,9,4,7,5,2,2,4,3,5,2,5,8,4,9,0,7,7,1,1,6,7,0,5,5,6,0,1,3,6,0,4,8,3,9,5,8,6,4,4,6,7,0,6,3,2,4,4,1,5,7,2,2,1,5,5,3,9,7,5,3,6,9,7,8,1,7,9,7,7,8,4,6,1,7,4,0,6,4,9,5,5,1,4,9,2,9,0,8,6,2,5,6,9,3,2,1,9,7,8,4,6,8,6,2,2,4,8,2,8,3,9,7,2,2,4,1,3,7,5,6,5,7,0,5,6,0,5,7,4,9,0,2,6,1,4,0,7,9,7,2,9,6,8,6,5,2,4,1,4,5,3,5,1,0,0,4,7,4,8,2,1,6,6,3,7,0,4,8,4,4,0,3,1,9,9,8,9,0,0,0,8,8,9,5,2,4,3,4,5,0,6,5,8,5,4,1,2,2,7,5,8,8,6,6,6,8,8,1,1,6,4,2,7,1,7,1,4,7,9,9,2,4,4,4,2,9,2,8,2,3,0,8,6,3,4,6,5,6,7,4,8,1,3,9,1,9,1,2,3,1,6,2,8,2,4,5,8,6,1,7,8,6,6,4,5,8,3,5,9,1,2,4,5,6,6,5,2,9,4,7,6,5,4,5,6,8,2,8,4,8,9,1,2,8,8,3,1,4,2,6,0,7,6,9,0,0,4,2,2,4,2,1,9,0,2,2,6,7,1,0,5,5,6,2,6,3,2,1,1,1,1,1,0,9,3,7,0,5,4,4,2,1,7,5,0,6,9,4,1,6,5,8,9,6,0,4,0,8,0,7,1,9,8,4,0,3,8,5,0,9,6,2,4,5,5,4,4,4,3,6,2,9,8,1,2,3,0,9,8,7,8,7,9,9,2,7,2,4,4,2,8,4,9,0,9,1,8,8,8,4,5,8,0,1,5,6,1,6,6,0,9,7,9,1,9,1,3,3,8,7,5,4,9,9,2,0,0,5,2,4,0,6,3,6,8,9,9,1,2,5,6,0,7,1,7,6,0,6,0,5,8,8,6,1,1,6,4,6,7,1,0,9,4,0,5,0,7,7,5,4,1,0,0,2,2,5,6,9,8,3,1,5,5,2,0,0,0,5,5,9,3,5,7,2,9,7,2,5,7,1,6,3,6,2,6,9,5,6,1,8,8,2,6,7,0,4,2,8,2,5,2,4,8,3,6,0,0,8,2,3,2,5,7,5,3,0,4,2,0,7,5,2,9,6,3,4,5,0]
#array to hold the 13 elements of the "sliding viewport" on n1000
n13=[];
#prime the "viewport" array with
#the first 13 elements from the n1000 array, [0] through [12]

v=0
n13.each do |v| 
   n13.push(n1000[v])
end
 
# prime winningProduct
zz=getProd(n13)
winningProduct=zz

## --------- end of priming --------

#initialize the two loop indexes
i=0
j=0

#getting each of the 1000 digits
while i < 1000
#reset the index for looping through the "viewport"  
  j=0  

#Have the 13 elements of n13 take turns 
#getting the next element from n1000    
  while j < 13
#One element of n13 now acquires tne next
#digit from n1000      
    n13[j]=n1000[i]
#get its new 'internal' product with its new digit (which of course replaced one of its
#prior set of elements)
    zz=getProd(n13)
# see whether this new set multiplies out to more than the prior highest product    
#If so, then update the current value      
    if zz > winningProduct
            winningProduct=zz
puts('new winningProduct:'+ winningProduct.to_s)
    end   #if
#update the loop indexes        
    i+=1
    j+=1
    end #while j
  end # while I

23514624000 

#9  Special Pythagorean triplet

A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
a2 + b2 = c2
For example, 32 + 42 = 9 + 16 = 25 = 52.
There exists exactly one Pythagorean triplet for which a + b + c = 1000.
Find the product abc.

(1..998).each do |x| 
  (1..998).each do |y|
    z=1000-x-y
    if (x**2) + (y**2) == (z**2)
      zxc=x*y*z    
      puts(zxc.to_s)      
      break
      end  # if
  end  #y
end  #x


#10  Summation of primes

The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
Find the sum of all the primes below two million.
 
require 'prime'
theSum=0
Prime.each(2000000) do |prime|
  theSum+=prime # Ret => [2, 3, 5, 7, 11, ..., 97]
  end
puts(theSum.to_s)
    
(Is it cheating to use Ruby prime?() function?  My code timed out on cloud9:

transitor= 11  
divisor=3
primeSum=28  #2,3,5,7,11
theMod=0
isPrime=true
while transitor< 2000000  
  transitor+=2
  divisor=3
  isPrime=true
  while divisor < transitor/2
    divisor+=2
    theMod=transitor % divisor
      if theMod == 0 
      isPrime=false;
      break
      end # if 
  end #while divisor < transitor/2
  if isPrime 
    primeSum+=transitor
  end # while t < 200
end   # while transit < 2 000 000

puts('Final: t=' + transitor.to_s + '  S=' + primeSum.to_s) 

31875000


